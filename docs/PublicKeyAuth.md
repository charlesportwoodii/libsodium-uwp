# Public Key signatures

Public key signatures are used to sign a given message which can then be verified by a third party.

> Note: Verifiers need to already know and ultimatly trust the public key before they can verify it.

## Generate KeyPair

__Namespace:__ _Sodium.PublicKeyAuth_

```C#
public static KeyPair Sodium.PublicKeyAuth.GenerateKeyPair()
public static KeyPair Sodium.PublicKeyAuth.GenerateKeyPair(byte[] seed)
```

A new key pair can be generated by calling `GenerateKeyPair` with or without a seed. If a seed is not specified, a new keypair will be generated. If a seed is specified, the seed should be 32 bytes.

_If a seed is specified, `crypto_sign_seed_keypair` will be used internally. Otherwise `crypto_sign_keypair` will be used._

# Combined mode

## Example
```C#
var message = System.Text.Encoding.UTF8.GetBytes("My secret message");
var keyPair = PublicKeyAuth.GenerateKeyPair(); // 64 byte private key | 32 byte public key

// Sign the message
var signature = PublicKeyAuth.Sign(message, keyPair.Secret);

// Verify the message signature
var unsignedMessage = PublicKeyAuth.Verify(signature, keyPair.Public);

// Messages should be the same.
// Assert.AreEqual(message, unsignedMessage);
```

## Sign

__Namespace:__ _Sodium.PublicKeyAuth_

```C#
public static byte[] Sodium.PublicKeyAuth.Sign(string message, byte[] privateKey)
public static byte[] Sodium.PublicKeyAuth.Sign(byte[] message, byte[] privateKey)
```

This method is used to sign a given `message` using a 64 byte `privateKey. This method will returns the signed message.

_This method internally uses `crypto_sign`._

## Verify

__Namespace:__ _Sodium.PublicKeyAuth_

```C#
public static byte[] Sodium.PublicKeyAuth.Verify(byte[] signedMessage, byte[] publicKey)
```

This method verifies the signature of a given `signedMessage` using the 32 byte `publicKey` associated with the 64 byte private key that originally signed the message.

_This method internally uses `crypto_sign_open`._

# Detached mode

Detached signatures may be generated as well. In detached mode, signatures are stored without a copy of the original message.

## Example

```C#
var kp = PublicKeyAuth.GenerateKeyPair();
string message = "Hello, World!";

// Generate a signature
var signature = PublicKeyAuth.SignDetached(message, kp.Secret);

if (PublicKeyAuth.VerifyDetached(sig1, message, kp.Public)) {
    // signature is valid
}
```

## Sign

__Namespace:__ _Sodium.PublicKeyAuth_

```C#
public static byte[] SignDetached(byte[] message, byte[] secretKey)
public static byte[] SignDetached(String message, byte[] secretKey)
```

Detached signatures for a given message by calling `SignDetached()` with the `message` and a 64 byte `secretKey`. This method will return a 64 byte signature.

_This method internally uses `crypto_sign_detached`._

## Verify

__Namespace:__ _Sodium.PublicKeyAuth_

```C#
public static bool VerifyDetached(byte[] signature, byte[] message, byte[] publicKey)
public static bool VerifyDetached(byte[] signature, String message, byte[] publicKey)
```

Signatures generated by `SignDetached` can be verified using the `VerifyDetached()` method, which accepts a 64 byte `signature` generated by `SignDetached`, the original `message`, and the corresponding 32 byte `publicKey` associated to the `secretKey` that signed the message.

_This method internally uses `crypto_sign_verify_detached`._

## Multi Part Signing

__Namespace:__ _Sodium.PublicKeyAuth_

```C#
void Append(IBuffer data)
public byte[] GetValueAndReset(byte[] secretKey)
public bool GetValueAndVerify(byte[] signature, byte[] public key)
```

Messages that do not fit into memory can be signed using the multi-part API as shown in the following example:

```C#
var kp = PublicKeyAuth.GenerateKeyPair();
var signature = new PublicKeyAuth();
IBuffer data = CryptographicBuffer.ConvertStringToBinary("Hello, World!", BinaryStringEncoding.Utf8);
signature.Append(data);

var output = signature.GetValueAndReset(kp.Secret);
Assert.AreEqual(64, output.Length);
Assert.AreEqual(true, signature.GetValueAndVerify(output, kp.Public));
```

Multi part data can be created using `Append()` on a new `PublicKeyAuth()` object. The signature can be retrieved by calling `GetValueAndReset()` with the secret key. The signature can be verified by calling `GetValueAndVerify()` with the signature and the public key.

_This method internally used `crypto_sign_init`, `crypto_sign_update`, `crypto_sign_final_create`, and `crypto_sign_final_verify`_
## Edd25519 to Curve25519 Key Conversion

### Convert Private Key

__Namespace:__ _Sodium.PublicKeyAuth_

```C#
public static byte[] Sodium.PublicKeyAuth.ConvertEd25519SecretKeyToCurve25519SecretKey(byte[] privateKey)
```

This method converts an 64 byte Ed25519 `privateKey` to a Curve25519 `privateKey`, and will return the Curve25519 private key.

_This method internally uses `crypto_sign_ed25519_pk_to_curve25519`._

### Convert Public key

__Namespace:__ _Sodium.PublicKeyAuth_

```C#
public static byte[] Sodium.PublicKeyAuth.ConvertEd25519PublicKeyToCurve25519PublicKey(byte[] publicKey)
```

This method converts an 32 byte Ed25519 `publicKey` to a Curve25519 `publicKey`, and will return the Curve25519 public key.

_This method internally uses `crypto_sign_ed25519_sk_to_curve25519`._

## Ed25519 Seed Extraction

Sodium provides two methods to extract information from the Ed25519 secret key.

### Extract Ed25519 seed from Ed25519 secret key

__Namespace:__ _Sodium.PublicKeyAuth_

```C#
public static byte[] ExtractEd25519SeedFromEd25519SecretKey(byte[] ed25519SecretKey)
```

_This method internally uses `crypto_sign_ed25519_sk_to_seed`._

### Extract Ed25519 public key from Ed25519 secret key

__Namespace:__ _Sodium.PublicKeyAuth_

```C#
public static byte[] ExtractEd25519PublicKeyFromEd25519SecretKey(byte[] ed25519SecretKey)
```

_This method internally uses `crypto_sign_ed25519_sk_to_pk`._

## Algorithm Details

- Signature: Ed25519